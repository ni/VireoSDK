<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Vireo: The Type Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Vireo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Vireo
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Compact runtime for Virtual Instruments</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The Type Manager </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the introduction, the VIs seen in the examples were running in a <em>ExecutionContext</em>, an object that manages scheduling the execution of clumps of code. A core element of each ExecutionContext is a TypeManager object that manages all types and data allocations needed during VI execution. TypeManagers can be nested allowing a parent TypeManager to provide types that are used by inherited by child TypeManagers.</p>
<p>To get better understanding of how the TypeManager works and how types are defined. Let's look at the examples VIs in a bit more detail; the VI itself is a new type, some parts internal to the VI are as well. When the VI decoder processes the define operation these types will be added to the ExecutionContext's TypeManager. Each step covers a bit more of the grammar VI assembly uses to describe types and data. There is also a <a href="md_dox__via_e_b_n_f.html">EBNF grammar</a> for the VIA text.</p>
<div class="fragment"><div class="line"><span class="comment">// Define a type named &quot;Calc&quot; that is a &quot;VirtualInstrument&quot;</span></div>
<div class="line">define (Calc  dv(.VirtualInstrument  (</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Define a cluster type with 6 elements that makes up the data space used by the VI.   </span></div>
<div class="line">    c(</div>
<div class="line">        <span class="comment">// Each element field in the cluster is a type defiition.</span></div>
<div class="line">        <span class="comment">// Some have non zero default values.</span></div>
<div class="line">        e(dv(.Int32 6)  i)</div>
<div class="line">        e(dv(.Int32 7)  j)</div>
<div class="line">        e(.Int32  k)</div>
<div class="line">        e(dv(.Double 6.0)  x)</div>
<div class="line">        e(dv(.Double 7.0)  y)</div>
<div class="line">        e(.Double  z)</div>
<div class="line">    )</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Specify a clump of instructions. Clumps are raw data used in the VIs definition.</span></div>
<div class="line">    <span class="comment">// They are not types.</span></div>
<div class="line">    clump(1 </div>
<div class="line">        <span class="comment">// However, the functions they reference are types . </span></div>
<div class="line">        Mul(i j k)   </div>
<div class="line">        Print(k)</div>
<div class="line">        Mul(x y z)</div>
<div class="line">        Print(k)</div>
<div class="line">    )</div>
<div class="line">) ) )</div>
</div><!-- fragment --><p>In addition to the types defined in the example there are several types referenced (<em>Int32</em>, <em>Double</em>, <em>VirtualInstrument</em>, <em>Mul</em> and <em>Print</em>). These types are defined in EggShell's root type manager and can be shared by all ExecutionContexts in the system. Before looking at details of the new types defined its important to look at how some of these core types are defined:</p>
<h3>Int32 type definition</h3>
<p>All types ultimately describe values that are represented by a block of bits. For simple types like <em>Int32</em> and <em>UInt32</em> the definitions look like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Int32 is a cluster with one element that is a BitBlock of 32 bits</span></div>
<div class="line"><span class="comment">// in signed 2&#39;s compliment encoding (SInt).</span></div>
<div class="line">define (Int32 c(e(bb(32 SInt))) )</div>
<div class="line"></div>
<div class="line"><span class="comment">// The UInt32 type only differs by its encoding.</span></div>
<div class="line">define (UInt32 c(e(bb(32 UInt))) )     </div>
</div><!-- fragment --><p>A <em>BitBlock</em> "bb(count encoding)", as the name says is a block of bits with a designated encoding.</p>
<p>A <em>Cluster</em> "c()" is a collection of zero or more <em>Elements</em> "e(type name)". Clusters round the storage allocation up to smallest addressable unit that meets the alignment requirements for the target architecture. The smallest addressable unit is called the Address Quantum Unit (<em>AQUnit</em>) and is typically a <em>Byte</em>/_Octet_ In the case of Int32 on a typical machine the 32 bits fit evenly into 4 AQUnits. This is referred to as the TopAQSize for the type. If the contained elements do not fit evenly into the cluster additional storage for padding is added.</p>
<p>Vireo includes built-in definitions for the integer types <em>UInt8</em>, <em>Int8</em>, <em>UInt16</em>, <em>Int16</em>, <em>UInt32</em>, <em>Int32</em>, <em>UInt64</em> and <em>Int64</em>. Note that there is no restriction to powers of 2 or multiples of 8. User code can define an Int5 though it will need to define functions that work with that type as well.</p>
<h3>Double type definition</h3>
<p>Some of the primitive types provide more detail about their internals. The type <em>Double</em> is has two definitions that are declared as equivalent. The first, like Int32, is a simple block of bits, in this case 64 bits in the <a href="http://en.wikipedia.org/wiki/IEEE_floating_point">IEEE754B</a> encoding. The second definition defines the actual layout of the bits using a <em>BitCluster</em> of BitBlocks. BitClusters differ from Clusters in that they pack their elements at the bit level.</p>
<p>Its common to think of an <em>Equivalence</em> as a C union, however, for an Equivalence all members must be the same bit size and it must be valid to view data from any of the views at any time. C unions do not have these restrictions.</p>
<div class="fragment"><div class="line"><span class="comment">// The low level single bit block definition</span></div>
<div class="line">define(DoubleAtomic     c(e(bb(64 IEEE754B))) )</div>
<div class="line"></div>
<div class="line"><span class="comment">// A definition that is more detailed</span></div>
<div class="line">define(DoubleCluster </div>
<div class="line">    <span class="comment">// This cluster contains a BitCluster, a packed set of BitBlock fields.</span></div>
<div class="line">    c(e(bc(</div>
<div class="line">        <span class="comment">// Clusters or BitCluster elements can have field names.</span></div>
<div class="line">        e(bb(1  Boolean)      sign) </div>
<div class="line">        e(bb(11 IntBiased)   exponent)</div>
<div class="line">        e(bb(52 Q1)          fraction)</div>
<div class="line">    )))</div>
<div class="line">)</div>
<div class="line"></div>
<div class="line"><span class="comment">// The user level definition allows either to be used. The first one is the default.</span></div>
<div class="line">define(Double eq(e(.DoubleAtomic) e(.DoubleCluster)) )</div>
</div><!-- fragment --><p>Vireo includes built-in definitions for the floating point types <em>Single</em>, <em>Double</em>, <em>ComplexSingle</em> and <em>ComplexDouble</em>.</p>
<h3>VirtualInstrument Type</h3>
<p>Internal types used in Vireo also have type definitions. Though the details are not going to be covered here, at the heart of a VirtualInstrument is a cluster of fields.</p>
<div class="fragment"><div class="line">define (VirtualInstrument </div>
<div class="line">    a(c(                               </div>
<div class="line">        e(.ExecutionContext Context)   </div>
<div class="line">        e(a(.*) ParamBlock)             </div>
<div class="line">        e(a(.*) DataSpace)              </div>
<div class="line">        e(a(.VIClump *) Clumps)     <span class="comment">// An array of clumps, see definition below.      </span></div>
<div class="line">        e(.Int32 lineNumberBase)    <span class="comment">// Internal fields for maping back to souce code    </span></div>
<div class="line">        e(.DataPointer ClumpSourceBegin)</div>
<div class="line">        e(.DataPointer ClumpSourceEnd)  </div>
<div class="line">    ))</div>
<div class="line">)</div>
<div class="line"></div>
<div class="line">define (VIClump</div>
<div class="line">    c(                                     </div>
<div class="line">        e(.InstructionList CodeStart)         </div>
<div class="line">        e(.DataPointer Next)                </div>
<div class="line">        e(.DataPointer Owner)               </div>
<div class="line">        e(.DataPointer NextWaitingCaller)   </div>
<div class="line">        e(.DataPointer Caller)              </div>
<div class="line">        e(.Instruction SavePC)              </div>
<div class="line">        e(.Int64 WakeUpInfo)                </div>
<div class="line">        e(.Int32 FireCount)                 </div>
<div class="line">        e(.Int32 ShortCount)                </div>
<div class="line">    )</div>
<div class="line">)</div>
</div><!-- fragment --><p>Using a single type system to describe internal data structures and dynamically defined ones from user code makes it easier to consistently allocate, copy and free the objects. It also makes it easier to develop functions core to the runtime in VIA source, thus it is not necessary to always use C++. With the proper privilege level it makes it possible for code dig into the internals of core data structures, For example it is possible to read a VIs array of clumps and write a simple disassembler in VIA code. In secure sand boxed mode these fields will not be accessible to most ExecutionContexts.</p>
<h3>Function Types</h3>
<p>The signatures for internal functions are also defined as standard types. The type definitions describe the <em>Parameter Block</em> used to pass parameters to the runtime function. Their syntax is similar to cluster definitions except that all elements must be designated as input, output, input-output. Since they are directly associated with C++ functions there are macro constructs that allow the C++ linker to associate the actual function address with each type definition. Here is what a few ParameterBlock type definitions from the examples look like:</p>
<div class="fragment"><div class="line"><span class="comment">// The print function takes one parameter, This is the raw parameter block definition</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//            p(i(.StaticTypeAndData))</span></div>
<div class="line"><span class="comment">// </span></div>
<div class="line"><span class="comment">// To bind the type to an actual function it will be part of the following:</span></div>
<div class="line"></div>
<div class="line">DEFINE_VIREO_BEGIN(LabVIEW_FileIO)</div>
<div class="line">    ... </div>
<div class="line">    DEFINE_VIREO_FUNCTION(Print, <span class="stringliteral">&quot;p(i(.StaticTypeAndData))&quot;</span>);</div>
<div class="line">    ...</div>
<div class="line">DEFINE_VIREO_END()</div>
</div><!-- fragment --><p>As noted, the Print function takes one parameter, but its a special one. The <em>StaticTypeAndData</em> type instructs the VIA decoder to generate code that passes both the parameter explicitly listed and the statically derivable type, Since they are passed internally as two separate parameters there is no need to <a href="http://en.wikipedia.org/wiki/Object_type_(object-oriented_programming">box</a>#Boxing) primitive data types.</p>
<div class="fragment"><div class="line">DEFINE_VIREO_BEGIN(LabVIEW_Math)</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// If many functions take a common signature then the signare can be it own named</span></div>
<div class="line">    <span class="comment">// type. The Generic binOp type takes three anythings.</span></div>
<div class="line">    DEFINE_VIREO_TYPE(GenericBinOp, <span class="stringliteral">&quot;p(i(.*) i(.*) o(.*))&quot;</span>)</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// The simple &quot;Mul&quot; function is generic. This means the function will be called at</span></div>
<div class="line">    <span class="comment">// load time and it will generate the appropriate runtime instruction. It is up</span></div>
<div class="line">    <span class="comment">// this function to determine if the types passed make sense.</span></div>
<div class="line">    DEFINE_VIREO_GENERIC(Mul, <span class="stringliteral">&quot;.GenericBinOp&quot;</span>, EmitGenericBinOpInstruction);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// The reference runtime does not generate cutoms code on the fly, it relies on</span></div>
<div class="line">    <span class="comment">// predefined primtitves. So the generic Mul function ends up binding to functions </span></div>
<div class="line">    <span class="comment">// like the following:</span></div>
<div class="line">    DEFINE_VIREO_FUNCTION(MulInt32,     <span class="stringliteral">&quot;.BinOpInt32&quot;</span>) </div>
<div class="line">    DEFINE_VIREO_FUNCTION(MulDouble,    &quot;.BinOpDouble&quot;) </div>
<div class="line"></div>
<div class="line">DEFINE_VIREO_END()</div>
</div><!-- fragment --><h3>Type Manager class hierarchy</h3>
<p>The base class for all types is <a class="el" href="class_vireo_1_1_type_common.html">TypeCommon</a>.</p>
<p>More to come.</p>
<h3>Types are values</h3>
<p>Every Type has a value, the default value is zeros. That means "Int32" can be passed as a zero value to any function that takes an Int32. Type with non zero defaults are <a class="el" href="class_vireo_1_1_default_value_type.html">DefaultValueType</a> types.</p>
<p>More to come.</p>
<h3>Type Manager scopes</h3>
<p>In the underlying C++ code within a thread there is always an active TypeManager <a class="el" href="class_vireo_1_1_type_manager_scope.html">Scope</a>.</p>
<p>More to come.</p>
<h3>In summary, the Periodic Table of types.</h3>
<p>The core metaphor used to describe Vireo's collection of types is the periodic table. If you set out to model chemistry you could enumerate core properties for molecules, elements, or atomic primitive elements (proton, neutron, electron). the layer you choose has a tremendous impact on the extensibility of the framework. As an example, if the element level is picked as a base level then definitions are needed for 118 core elements. However if atomic weight becomes relevant to the system then 288 are needed to account for all known <a href="http://en.wikipedia.org/wiki/List_of_elements_by_stability_of_isotopes">isotopes</a>. If instead the core particles are defined and a means for aggregating them, then only a small handful of concepts are needed, and it is easy to dynamically add new ones without adding more C++ code to the core app. Starting with a single bit and ways to aggregate collections of them is the strategy Vireo uses.</p>
<h2>Next Steps</h2>
<ul>
<li><a href="index.html">Introduction</a></li>
<li><a href="md_dox__intro_type_examples.html">Some more simple type examples</a></li>
<li><a href="md_dox__intro_array_examples.html">Some array type examples</a></li>
<li><a href="md_dox__intro_parallel_clump_examples.html">VIs with parallel execution</a></li>
<li><a href="md_dox__type_manager.html">The TypeManager</a> </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
