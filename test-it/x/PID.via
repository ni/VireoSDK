// Copyright (c) 2020 National Instruments
// SPDX-License-Identifier: MIT

// Autogenerated Vireo assembly file
// Generated on Tue Oct 29 14:46:57 2013

//---------------------------------------------------
//VI Definition: PID.vi
define(CalcPid v(.VirtualInstrument (
    c(
        o(v(.Double 0) fp1)         // output
        i(v(.Boolean false) fp2)    // reinitialize? (F)
        i(c(
            e(v(.Double 100) n3)    // output high
            e(v(.Double -100) n4)   // output low
        ) fp5)   // output range
        i(v(.Double 0.01) fp6)      // dt (s)
        i(c(
            e(v(.Double 1) n7)      // proportional gain (Kc)
            e(v(.Double 0.01) n8)   // integral time (Ti min)
            e(v(.Double 0) n9)      // derivative time (Td min)
        ) fp10)                     // PID gains
        i(v(.Double 0) fp11)        // process variable
        i(v(.Double 42.42) fp12)    // setpoint
    )
    c(
        e(v(.Boolean true) c13)
        e(v(.Double 0) c14)   // y
        e(v(.Double 0.5) c15)   // y
        e(v(.Double 0.0166667) c16)   // result of 1/60
        e(v(.Boolean true) c17)
        e(v(.Boolean false) c18)
        e(v(.Double 0) c19)
        e(.Double w20)
        e(.Double w21)   // proportional gain (Kc)
        e(.Double w22)   // integral time (Ti min)
        e(.Double w23)   // derivative time (Td min)
        e(.Boolean w24)
        e(.Double w25)
        e(.Double w26)   // y
        e(.Double w27)
        e(.Double w28)
        e(.Double w29)
        e(.Double w30)
        e(.Boolean w31)
        e(.Boolean w32)
        e(.Boolean w33)   // reinitialize? (F)
        e(.Double w34)   // process variable
        e(.Double w35)   // proportional gain (Kc)
        e(.Double w36)   // proportional gain (Kc)
        e(.Double w37)   // integral time (Ti min)
        e(.Double w38)   // integral time (Ti min)
        e(.Double w39)   // derivative time (Td min)
        e(.Double w40)   // derivative time (Td min)
        e(.Double w41)   // process variable
        e(.Double w42)   // process variable
        e(.Double w43)
        e(.Double w44)
        e(.Double w45)
        e(.Double w46)
        e(.Double w47)
        e(.Double w48)
        e(.Double w49)
        e(.Double w50)
        e(.Boolean w51)
        e(.Boolean w52)
        e(.Boolean w53)
        e(.Boolean w54)
        e(.Boolean w55)
        e(.Double w56)
        e(.Double w57)
        e(.Double w58)
        e(.Double w59)
        e(.Double w60)
        e(.Double w61)   // process variable
        e(.Double w62)   // process variable
        e(.Double w63)
        e(.Double w64)
        e(.Boolean w65)
        e(.Double w66)
        e(.Double w67)
        e(.Double w68)
        e(.Double w69)
        e(.Double w70)
        e(.Double w71)
        e(.Double w72)
        e(.Double w73)
        e(.Double w74)
        e(.Double w75)
        e(.Double w76)
        e(.Double w77)
        e(.Double w78)
        e(.Double w79)
    )
    1 
    clump(1 
        Printf("pv <%s>  sp<%s>\n" fp11 fp12)
       Println(fp10)
        Sub(fp12 fp11 w20)
        Copy(fp10.n7 w21 )                        // unbundle
        Copy(fp10.n8 w22 )                        // unbundle
        Copy(fp10.n9 w23 )                        // unbundle
        IsNEDouble(w22 c19 w24)
//--- begin case structure
        BranchIfTrue(0 w24)                      // CaseStructure test
//--- default case
        Copy(c14 w26 )                            // case output tunnel
        Copy(c14 w27 )                            // case output tunnel
        Branch(1)
//--- case
        Perch(0)
        Div(w21 w22 w25)
        Copy(c15 w26 )                            // case output tunnel
        Copy(w25 w27 )                            // case output tunnel
//--- end case structure
        Perch(1)
        Mul(w23 w21 w28)
        Mul(w20 w21 w29)
        Mul(c16 fp6 w30)
//--- begin case structure
        BranchIfTrue(2 fp2)                      // CaseStructure test
//--- default case
        IsGTDouble(w30 c19 w31)
        Copy(w31 w32 )                            // case output tunnel
        Branch(3)
//--- case
        Perch(2)
        Copy(c18 w32 )           // case output tunnel
//--- end case structure
        Perch(3)
        Copy(fp2 w33 )
        Copy(fp11 w34 )
//--- begin while loop
        Perch(3)
        Copy(w36 w35 )           // LSR copy into inner wire
        Copy(w38 w37 )                            // LSR copy into inner wire
        Copy(w40 w39 )                            // LSR copy into inner wire
        Copy(w42 w41 )                            // LSR copy into inner wire
        Copy(w44 w43 )                            // LSR copy into inner wire
        Copy(w46 w45 )                            // LSR copy into inner wire
        Copy(w48 w47 )                            // LSR copy into inner wire
        Copy(w50 w49 )                            // LSR copy into inner wire
        IsEQDouble(w23 w39 w51)
        IsEQDouble(w22 w37 w52)
        IsEQDouble(w21 w35 w53)
        And(w53 w52 w54)
        And(w54 w51 w55)
//--- begin case structure
        BranchIfTrue(6 w33)                      // CaseStructure test
//--- default case
//--- begin case structure
        BranchIfTrue(4 w32)                      // CaseStructure test
//--- default case
        Copy(w43 w60 )                            // case output tunnel
        Copy(w41 w61 )                            // case output tunnel
        Branch(5)
//--- case
        Perch(4)
        Sub(w34 w41 w56)
        Sub(c19 w56 w57)
        Mul(w28 w57 w58)
        Div(w58 w30 w59)
        Copy(w59 w60 )                            // case output tunnel
        Copy(w34 w61 )                            // case output tunnel
//--- end case structure
        Perch(5)
        Copy(w61 w62 )           // case output tunnel
        Copy(w60 w63 )                            // case output tunnel
        Branch(7)
//--- case
        Perch(6)
        Copy(w34 w62 )           // case output tunnel
        Copy(c19 w63 )                            // case output tunnel
//--- end case structure
//--- begin case structure
        Perch(7)
        BranchIfTrue(8 w24)     // CaseStructure test
//--- default case
        Add(w29 w63 w64)
        Copy(c19 w78 )                            // case output tunnel
        Copy(w64 w79 )                            // case output tunnel
        Branch(12)
//--- case
        Perch(8)
        Or(w33 w55 w65)
        Add(w20 w47 w66)
        Mul(w66 w26 w67)
        Mul(w67 w27 w68)
        Mul(w68 w30 w69)
        Add(w69 w49 w70)
//--- begin case structure
        BranchIfTrue(9 w65)                      // CaseStructure test
//--- default case
        Add(w29 w63 w71)
        Sub(w45 w71 w72)
        Copy(w72 w76 )                            // case output tunnel
        Copy(w45 w77 )                            // case output tunnel
        Branch(11)
//--- case
//--- begin case structure
        Perch(9)
        BranchIfTrue(10 w33)    // CaseStructure test
//--- default case
        Copy(w70 w73 )                            // case output tunnel
        Branch(11)
//--- case
        Perch(10)
        Copy(c19 w73 )          // case output tunnel
//--- end case structure
        Perch(11)
        Add(w73 w29 w74)
        Add(w74 w63 w75)
        Copy(w73 w76 )                            // case output tunnel
        Copy(w75 w77 )                            // case output tunnel
//--- end case structure
        Perch(11)
        Copy(w76 w78 )          // case output tunnel
        Copy(w77 w79 )                            // case output tunnel
//--- end case structure
        Perch(12)
        Copy(w21 w36 )
        Copy(w22 w38 )
        Copy(w23 w40 )
        Copy(w62 w42 )
        Copy(w63 w44 )
        Copy(w79 w46 )
        Copy(w20 w48 )
        Copy(w78 w50 )
        BranchIfFalse(13 c18)                    // Loop condition terminal
        Branch(3)                                 // loop again
//--- end while loop
        Perch(13)
        Copy(w46 fp1 )          // FP Term
        Printf("output <%s>\n" fp1)
//--- end of vi
    )
)))

define(RunPid v(.VirtualInstrument (
        c(
        e(v(.Boolean false) cFalse)
        e(v(.Boolean true) cTrue)
        e(v(.Double 0) fp1)         // output
        e(v(.Boolean false) fp2)    // reinitialize? (F)
        e(c(
            e(v(.Double 100) n3)    // output high
            e(v(.Double -100) n4)   // output low
        ) fp5)   // output range
        e(v(.Double 0.01) fp6)      // dt (s)
        e(c(
            e(v(.Double 1) n7)      // proportional gain (Kc)
            e(v(.Double 0.01) n8)   // integral time (Ti min)
            e(v(.Double 0) n9)      // derivative time (Td min)
        ) fp10)                     // PID gains
        e(v(.Double 0) fp11)        // process variable
        e(v(.Double 42.42) fp12)    // setpoint
    )
    1
    clump 
    (1
        CalcPid(fp1 cFalse fp5 fp6 fp10 fp11 fp12)
        CalcPid(fp1 cFalse fp5 fp6 fp10 fp11 fp12)
        CalcPid(fp1 cFalse fp5 fp6 fp10 fp11 fp12)
        CalcPid(fp1 cFalse fp5 fp6 fp10 fp11 fp12)
        CalcPid(fp1 cFalse fp5 fp6 fp10 fp11 fp12)
    )
) ) )

enqueue(RunPid)
