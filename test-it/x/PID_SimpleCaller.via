// Copyright (c) 2020 National Instruments
// SPDX-License-Identifier: MIT

// Autogenerated Vireo assembly file
// Generated on Tue Oct 29 13:21:10 2013

//---------------------------------------------------
//VI Definition: PID SimpleCaller.vi
define(videf1 v(.VirtualInstrument (
    c(
        e(v(.Double 0) c1)   // output
        e(v(.Boolean true) c2)
        e(v(.Double 0.01) c3)
        e(v(.Double 0.5) c4)   // y
        e(v(.Double 0.0166667) c5)   // result of 1/60
        e(v(.Boolean false) c6)
        e(v(.Int32 0) c7)
        e(v(.Int32 1) c8)
        e(.Int32 w9)
        e(.Double w10)   // output
        e(v(.Double 33.936) fp11)   // output
    )
    1
    clump(1
        Copy(c1 w10 )                             // Pre-Loop copy into LSR
        Copy(c7 w9 )                              // initialize i
//--- begin while loop
        Perch(0)
        Copy(w10 w12 )           // LSR copy into inner wire
        IsEQInt32(w9, c7, w13)
        videf2(w14 w13 fp15 c3 fp16 w12 fp17)
        Copy(w14 w10 )
        BranchIfTrue(1, c2)                       // Loop condition terminal
        Add(w9 c8 w9)                             // increment i
        Branch(0)                                 // loop again
//--- end while loop
        Perch(1)
        Copy(w10 fp11 )          // FP Term
//--- end of vi
    )
)))
//---------------------------------------------------
//VI Definition: PID.vi
define(videf2, v(.VirtualInstrument, (
    c(
        e(v(.Double 0) fp18)   // output
        e(v(.Boolean false) fp19)   // reinitialize? (F)
        e(c(
            e(v(.Double 100) n20)   // output high
            e(v(.Double -100) n21)   // output low
        ) fp22)   // output range
        e(v(.Double -1) fp23)   // dt (s)
        e(c(
            e(v(.Double 1) n24)   // proportional gain (Kc)
            e(v(.Double 0.01) n25)   // integral time (Ti, min)
            e(v(.Double 0) n26)   // derivative time (Td, min)
        ) fp27)   // PID gains
        e(v(.Double 0) fp28)   // process variable
        e(v(.Double 0) fp29)   // setpoint
    )
    c(
        e(v(.Double 0) c1)   // output
        e(v(.Boolean true) c2)
        e(v(.Double 0.01) c3)
        e(v(.Double 0.5) c4)   // y
        e(v(.Double 0.0166667) c5)   // result of 1/60
        e(v(.Boolean false) c6)
        e(v(.Int32 0) c7)
        e(v(.Int32 1) c8)
        e(.Double w30)
        e(.Double w31)   // proportional gain (Kc)
        e(.Double w32)   // integral time (Ti, min)
        e(.Double w33)   // derivative time (Td, min)
        e(.Boolean w34)
        e(.Double w35)
        e(.Double w36)   // y
        e(.Double w37)
        e(.Double w38)
        e(.Double w39)
        e(.Double w40)
        e(.Boolean w41)
        e(.Boolean w42)
        e(.Boolean w43)   // reinitialize? (F)
        e(.Double w44)   // process variable
        e(.Double w45)   // proportional gain (Kc)
        e(.Double w46)   // proportional gain (Kc)
        e(.Double w47)   // integral time (Ti, min)
        e(.Double w48)   // integral time (Ti, min)
        e(.Double w49)   // derivative time (Td, min)
        e(.Double w50)   // derivative time (Td, min)
        e(.Double w51)   // process variable
        e(.Double w52)   // process variable
        e(.Double w53)
        e(.Double w54)
        e(.Double w55)
        e(.Double w56)
        e(.Double w57)
        e(.Double w58)
        e(.Double w59)
        e(.Double w60)
        e(.Boolean w61)
        e(.Boolean w62)
        e(.Boolean w63)
        e(.Boolean w64)
        e(.Boolean w65)
        e(.Double w66)
        e(.Double w67)
        e(.Double w68)
        e(.Double w69)
        e(.Double w70)
        e(.Double w71)   // process variable
        e(.Double w72)   // process variable
        e(.Double w73)
        e(.Double w74)
        e(.Boolean w75)
        e(.Double w76)
        e(.Double w77)
        e(.Double w78)
        e(.Double w79)
        e(.Double w80)
        e(.Double w81)
        e(.Double w82)
        e(.Double w83)
        e(.Double w84)
        e(.Double w85)
        e(.Double w86)
        e(.Double w87)
        e(.Double w88)
        e(.Double w89)
        e(v(.Int32 -1) w90)
    )
    1,
    clump(1,
        Sub(fp29 fp28 w30)
        Copy(fp27.n24 w31 )                       // unbundle
        Copy(fp27.n25 w32 )                       // unbundle
        Copy(fp27.n26 w33 )                       // unbundle
        IsNEDouble(w32, c1, w34)
//--- begin case structure
        BranchIfTrue(0, w34)                      // CaseStructure test
//--- default case
        Copy(c1 w36 )                             // case output tunnel
        Copy(c1 w37 )                             // case output tunnel
        Branch(1)
//--- case
        Perch(0)
        Div(w31 w32 w35)
        Copy(c4 w36 )                             // case output tunnel
        Copy(w35 w37 )                            // case output tunnel
//--- end case structure
        Perch(1)
        Mul(w33 w31 w38)
        Mul(w30 w31 w39)
        Mul(c5 fp23 w40)
//--- begin case structure
        BranchIfTrue(2, fp19)                     // CaseStructure test
//--- default case
        IsGTDouble(w40, c1, w41)
        Copy(w41 w42 )                            // case output tunnel
        Branch(3)
//--- case
        Perch(2)
        Copy(c6 w42 )            // case output tunnel
//--- end case structure
        Perch(3)
        Copy(fp19 w43 )
        Copy(fp28 w44 )
//--- begin while loop
        Perch(3)
        Copy(w46 w45 )           // LSR copy into inner wire
        Copy(w48 w47 )                            // LSR copy into inner wire
        Copy(w50 w49 )                            // LSR copy into inner wire
        Copy(w52 w51 )                            // LSR copy into inner wire
        Copy(w54 w53 )                            // LSR copy into inner wire
        Copy(w56 w55 )                            // LSR copy into inner wire
        Copy(w58 w57 )                            // LSR copy into inner wire
        Copy(w60 w59 )                            // LSR copy into inner wire
        IsEQDouble(w33, w49, w61)
        IsEQDouble(w32, w47, w62)
        IsEQDouble(w31, w45, w63)
        And(w63 w62 w64)
        And(w64 w61 w65)
//--- begin case structure
        BranchIfTrue(6, w43)                      // CaseStructure test
//--- default case
//--- begin case structure
        BranchIfTrue(4, w42)                      // CaseStructure test
//--- default case
        Copy(w53 w70 )                            // case output tunnel
        Copy(w51 w71 )                            // case output tunnel
        Branch(5)
//--- case
        Perch(4)
        Sub(w44 w51 w66)
        Sub(c1 w66 w67)
        Mul(w38 w67 w68)
        Div(w68 w40 w69)
        Copy(w69 w70 )                            // case output tunnel
        Copy(w44 w71 )                            // case output tunnel
//--- end case structure
        Perch(5)
        Copy(w71 w72 )           // case output tunnel
        Copy(w70 w73 )                            // case output tunnel
        Branch(7)
//--- case
        Perch(6)
        Copy(w44 w72 )           // case output tunnel
        Copy(c1 w73 )                             // case output tunnel
//--- end case structure
//--- begin case structure
        Perch(7)
        BranchIfTrue(8, w34)     // CaseStructure test
//--- default case
        Add(w39 w73 w74)
        Copy(c1 w88 )                             // case output tunnel
        Copy(w74 w89 )                            // case output tunnel
        Branch(12)
//--- case
        Perch(8)
        Or(w43 w65 w75)
        Add(w30 w57 w76)
        Mul(w76 w36 w77)
        Mul(w77 w37 w78)
        Mul(w78 w40 w79)
        Add(w79 w59 w80)
//--- begin case structure
        BranchIfTrue(9, w75)                      // CaseStructure test
//--- default case
        Add(w39 w73 w81)
        Sub(w55 w81 w82)
        Copy(w82 w86 )                            // case output tunnel
        Copy(w55 w87 )                            // case output tunnel
        Branch(11)
//--- case
//--- begin case structure
        Perch(9)
        BranchIfTrue(10, w43)    // CaseStructure test
//--- default case
        Copy(w80 w83 )                            // case output tunnel
        Branch(11)
//--- case
        Perch(10)
        Copy(c1 w83 )           // case output tunnel
//--- end case structure
        Perch(11)
        Add(w83 w39 w84)
        Add(w84 w73 w85)
        Copy(w83 w86 )                            // case output tunnel
        Copy(w85 w87 )                            // case output tunnel
//--- end case structure
        Perch(11)
        Copy(w86 w88 )          // case output tunnel
        Copy(w87 w89 )                            // case output tunnel
//--- end case structure
        Perch(12)
        Copy(w31 w46 )
        Copy(w32 w48 )
        Copy(w33 w50 )
        Copy(w72 w52 )
        Copy(w73 w54 )
        Copy(w89 w56 )
        Copy(w30 w58 )
        Copy(w88 w60 )
        BranchIfFalse(13, c6)                     // Loop condition terminal
        Branch(3)                                 // loop again
//--- end while loop
        Perch(13)
        Copy(w56 fp18 )         // FP Term
//--- end of vi
    )
)))
enqueue(videf1)
